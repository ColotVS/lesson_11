public class lesson_11_26 {
    //Метод equals()

    //Унаследованный от класса Object метод equals() содержит самый простой алгоритм сравнивания текущего и переданного объектов —
    //он просто сравнивает их ссылки.
    //Тот же эффект вы получите, если просто сравните переменные класса Person вместо вызова метода equals().
    //Метод equals просто сравнивает у себя внутри ссылки a и b.

    //Однако у класса String сравнение работает по-другому. Почему?
    //Потому что разработчики класса String написали собственную реализацию метода equals().

    //Реализация метода equals()
    //Давайте и мы напишем свою реализацию метода equals в классе Person. Разберем 4 основных случая.
    //Важно:
    //Вне зависимости от того, для какого класса переопределять метод equals, он всегда принимает параметр типа Object

    //Сценарий 1: в метод equals передали тот же самый объект, у которого вызвали метод equals.
    //Если ссылки у текущего и переданного объектов равны, нужно вернуть true. Объект совпадает сам с собой.
    //В коде это будет выглядеть так:
    //public boolean equals(Object obj)
    //{
    //   if (this == obj)               //Сравниваем ссылки
    //    return true;
    //
    //   остальной код метода equals
    //}

    //Сценарий 2: в метод equals передали ссылку null — сравнивать не с чем.
    //Объект, у которого вызвали метод equals, точно не null, значит, в этом случае нужно вернуть false.
    //В коде это будет выглядеть так:
    //public boolean equals(Object obj)
    //{
    //   if (this == obj)               //Сравниваем ссылки
    //      return true;
    //
    //   if (obj == null)               //Переданный объект — null?
    //      return false;
    //
    //   остальной код метода equals
    //}

    //Сценарий 3: в метод equals передали ссылку на объект вообще не класса Person.
    //Равен ли объект класса Person объекту класса не-Person? Тут уже решает сам разработчик класса Person — как хочет, так и сделает.
    //Но обычно все же объекты считаются равными, если это объекты одного класса.
    //Поэтому если в наш метод equals передали объект не класса Person, мы будем всегда возвращать false.
    //А как проверить, какого типа объект? Правильно: с помощью оператора instanceof.
    //Вот как будет выглядеть наш новый код:
    //public boolean equals(Object obj)
    //{
    //   if (this == obj)               //Сравниваем ссылки
    //      return true;
    //
    //   if (obj == null)               //Переданный объект — null?
    //      return false;
    //
    //   if (!(obj instanceof Person))  //Если переданный объект не типа Person
    //      return false;
    //
    //   остальной код метода equals
    //}

    //Сравнение двух объектов Person
    //Что мы получили в итоге? Если мы дошли до конца метода, значит, у нас объект типа Person и ссылка не null.
    //Тогда преобразовываем его к типу Person и будем сравнивать внутренности обоих объектов. Это и есть наш сценарий номер 4.
    //public boolean equals(Object obj)
    //{
    //   if (this == obj)               //Сравниваем ссылки
    //      return true;
    //
    //   if (obj == null)               //Переданный объект — null?
    //      return false;
    //
    //   if (!(obj instanceof Person))  //Если переданный объект не типа Person
    //      return false;
    //
    // Person person = (Person) obj;    //Операция приведения типа
    //
    //   остальной код метода equals
    //}

    //А как сравнивать два объекта Person? Они равны, если у них равны имена (name) и возраст (age). Итоговый код будет выглядеть так:
    //public boolean equals(Object obj)
    //{
    //   if (this == obj)                //Сравниваем ссылки
    //      return true;
    //
    //   if (obj == null)               //Переданный объект — null?
    //      return false;
    //
    //   if (!(obj instanceof Person))  //Если переданный объект не типа Person
    //      return false;
    //
    //   Person person = (Person) obj;  //Операция приведения типа
    //
    //   return this.name == person.name && this.age == person.age;
    //}

    //И это еще не все.
    //Во-первых, поле name имеет тип String, а значит, поля name нужно сравнивать с помощью вызова метода equals.
    //Во-вторых, поле name вполне себе может быть равным null: тогда вызвать метод equals у него нельзя.
    //Нужна дополнительная проверка на null
    //Однако если name равно null в обоих объектах Person, имена все-таки равны.
    //Код четвертого сценария может выглядеть, например, так:
    //public boolean equals(Object obj)
    //{
    //   if (this == obj)                //Сравниваем ссылки
    //      return true;
    //
    //   if (obj == null)               //Переданный объект — null?
    //      return false;
    //
    //   if (!(obj instanceof Person))  //Если переданный объект не типа Person
    //      return false;
    //
    //  Person person = (Person) obj;   ////Операция приведения типа
    //
    //  if (this.age != person.age)     //Если возрасты не равны, сразу return false
    //   return false;
    //
    //  if (this.name == null)          //Если this.name равно null, нет смысла сравнивать через equals.
    //   return person.name == null;    //Тут либо второе поле name равно null, либо нет.
    //
    //  return this.name.equals(person.name); //Сравниваем два поля name через equals.



}
